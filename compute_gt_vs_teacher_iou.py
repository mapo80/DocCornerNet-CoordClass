#!/usr/bin/env python3
"""
Compute IoU between dataset GT polygons and cached teacher pseudo-GT polygons.

Inputs:
  - <data_root>/{train,val}.txt                     (split lists)
  - <data_root>/labels/<image_stem>.txt             (YOLO polygon GT: class x0 y0 ... x3 y3)
  - <data_root>/{train,val}_teacher.txt             (generated by generate_teacher_gt_splits.py)

Outputs (one CSV per split):
  - <out_dir>/train_gt_vs_teacher_iou.csv
  - <out_dir>/val_gt_vs_teacher_iou.csv

Notes:
  - Positives only (filenames not starting with "negative_").
  - If the teacher didn't detect corners for an image, IoU is 0 and teacher_detected=0.
  - If GT is missing/invalid, the row is kept with gt_valid=0 and iou blank.
"""

from __future__ import annotations

import argparse
import csv
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Optional

import numpy as np
from shapely.geometry import Polygon
from shapely.validation import make_valid
from tqdm import tqdm


def _timestamp() -> str:
    return time.strftime("%Y%m%d_%H%M%S")


def _read_split_lines(path: Path) -> list[str]:
    lines: list[str] = []
    for raw in path.read_text().splitlines():
        name = raw.strip()
        if not name:
            continue
        if name.startswith("images/"):
            name = name[len("images/") :]
        elif name.startswith("images-negative/"):
            name = name[len("images-negative/") :]
        lines.append(name)
    return lines


def _load_yolo_polygon(label_path: Path) -> Optional[np.ndarray]:
    """
    Returns normalized coords [8] or None if missing/invalid.
    YOLO polygon format: class x0 y0 x1 y1 x2 y2 x3 y3
    """
    if not label_path.exists():
        return None
    try:
        line = label_path.read_text().strip().splitlines()[0].strip()
    except Exception:
        return None
    if not line:
        return None
    parts = line.split()
    if len(parts) < 9:
        return None
    if parts[0] != "0":
        return None
    try:
        coords = np.array([float(x) for x in parts[1:9]], dtype=np.float32)
    except Exception:
        return None
    if coords.shape != (8,) or not np.all(np.isfinite(coords)):
        return None
    return coords


def _order_points_ccw(pts: np.ndarray) -> np.ndarray:
    c = pts.mean(axis=0)
    angles = np.arctan2(pts[:, 1] - c[1], pts[:, 0] - c[0])
    return pts[np.argsort(angles)]


def _poly_from_quad(coords8: np.ndarray) -> Optional[Polygon]:
    pts = coords8.reshape(4, 2)
    pts = _order_points_ccw(pts)
    try:
        poly = Polygon([(float(x), float(y)) for x, y in pts])
    except Exception:
        return None

    if poly.is_empty:
        return None

    if not poly.is_valid:
        try:
            poly2 = make_valid(poly)
        except Exception:
            return None
        if poly2.is_empty:
            return None
        if poly2.geom_type == "Polygon":
            poly = poly2
        elif poly2.geom_type == "MultiPolygon":
            poly = max(poly2.geoms, key=lambda p: p.area)
        elif poly2.geom_type == "GeometryCollection":
            polys = [g for g in poly2.geoms if g.geom_type == "Polygon"]
            poly = max(polys, key=lambda p: p.area) if polys else None
            if poly is None:
                return None
        else:
            return None

    if poly.area <= 0.0:
        return None
    return poly


def _iou(poly_a: Polygon, poly_b: Polygon) -> float:
    inter = float(poly_a.intersection(poly_b).area)
    union = float(poly_a.union(poly_b).area)
    if union <= 0.0:
        return 0.0
    return float(inter / union)


@dataclass(frozen=True)
class TeacherPred:
    detected: int
    conf: float
    coords: np.ndarray  # [8] normalized, may be -1 if not detected


def _load_teacher_split_file(path: Path) -> dict[str, TeacherPred]:
    """
    Load <split>_teacher.txt created by generate_teacher_gt_splits.py.

    Format (11 tokens):
      filename detected conf x0 y0 x1 y1 x2 y2 x3 y3
    """
    out: dict[str, TeacherPred] = {}
    with path.open("r") as f:
        for line in f:
            parts = line.strip().split()
            if not parts:
                continue
            if len(parts) != 11:
                continue
            name = parts[0]
            try:
                detected = int(parts[1])
                conf = float(parts[2])
                coords = np.array([float(x) for x in parts[3:11]], dtype=np.float32)
            except Exception:
                continue
            if coords.shape != (8,) or not np.all(np.isfinite(coords)):
                continue
            out[name] = TeacherPred(detected=detected, conf=conf, coords=coords)
    return out


def parse_args() -> argparse.Namespace:
    p = argparse.ArgumentParser(
        description="Compute per-image IoU between GT and teacher pseudo-GT for train/val splits.",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
    )
    p.add_argument(
        "--data_root",
        type=str,
        default="/Volumes/ZX20/ML-Models/DocScannerDetection/datasets/official/doc-scanner-dataset-rev-new",
        help="Dataset root (contains images/, labels/, train.txt, val.txt, train_teacher.txt, val_teacher.txt).",
    )
    p.add_argument("--splits", type=str, default="train,val", help="Comma-separated split basenames")
    p.add_argument(
        "--out_dir",
        type=str,
        default="",
        help="Output directory. If empty, writes next to the dataset (data_root).",
    )
    p.add_argument(
        "--min_conf",
        type=float,
        default=0.0,
        help="If >0, keep an extra column iou_at_min_conf (else blank) computed only when teacher_conf>=min_conf.",
    )
    p.add_argument(
        "--diff_iou",
        type=float,
        default=0.90,
        help="Consider an image 'different' if teacher_detected==0 OR IoU < diff_iou.",
    )
    p.add_argument(
        "--write_diff_files",
        action="store_true",
        help="Also write <split>_gt_vs_teacher_diff.csv and <split>_gt_vs_teacher_diff.txt.",
    )
    return p.parse_args()


def main() -> None:
    args = parse_args()
    data_root = Path(args.data_root)
    splits = [s.strip() for s in str(args.splits).split(",") if s.strip()]
    out_dir = Path(args.out_dir) if args.out_dir else data_root
    out_dir.mkdir(parents=True, exist_ok=True)

    for split in splits:
        split_file = data_root / f"{split}.txt"
        teacher_file = data_root / f"{split}_teacher.txt"
        if not split_file.exists():
            raise SystemExit(f"Missing split file: {split_file}")
        if not teacher_file.exists():
            raise SystemExit(f"Missing teacher split file: {teacher_file} (run generate_teacher_gt_splits.py)")

        names = _read_split_lines(split_file)
        positives = [n for n in names if not n.startswith("negative_")]
        teacher_map = _load_teacher_split_file(teacher_file)

        out_path = out_dir / f"{split}_gt_vs_teacher_iou.csv"
        diff_csv_path = out_dir / f"{split}_gt_vs_teacher_diff.csv"
        diff_txt_path = out_dir / f"{split}_gt_vs_teacher_diff.txt"
        fields = [
            "split",
            "filename",
            "gt_valid",
            "teacher_detected",
            "teacher_conf",
            "iou",
            "iou_at_min_conf",
        ]

        rows_written = 0
        diff_rows_written = 0
        missing_teacher = 0
        missing_gt = 0
        ious: list[float] = []
        diff_filenames: list[str] = []

        diff_writer: Optional[csv.DictWriter] = None
        diff_f = None
        if bool(args.write_diff_files):
            diff_f = diff_csv_path.open("w", newline="")
            diff_writer = csv.DictWriter(diff_f, fieldnames=fields)
            diff_writer.writeheader()

        with out_path.open("w", newline="") as f:
            w_all = csv.DictWriter(f, fieldnames=fields)
            w_all.writeheader()

            for filename in tqdm(positives, desc=f"IoU ({split})"):
                gt_coords = _load_yolo_polygon(data_root / "labels" / (Path(filename).stem + ".txt"))
                if gt_coords is None:
                    missing_gt += 1
                    row = {
                        "split": split,
                        "filename": filename,
                        "gt_valid": 0,
                        "teacher_detected": "",
                        "teacher_conf": "",
                        "iou": "",
                        "iou_at_min_conf": "",
                    }
                    w_all.writerow(row)
                    rows_written += 1
                    continue

                gt_poly = _poly_from_quad(gt_coords)
                if gt_poly is None:
                    missing_gt += 1
                    row = {
                        "split": split,
                        "filename": filename,
                        "gt_valid": 0,
                        "teacher_detected": "",
                        "teacher_conf": "",
                        "iou": "",
                        "iou_at_min_conf": "",
                    }
                    w_all.writerow(row)
                    rows_written += 1
                    continue

                sb = teacher_map.get(filename, None)
                if sb is None:
                    missing_teacher += 1
                    row = {
                        "split": split,
                        "filename": filename,
                        "gt_valid": 1,
                        "teacher_detected": 0,
                        "teacher_conf": 0.0,
                        "iou": 0.0,
                        "iou_at_min_conf": (0.0 if float(args.min_conf) <= 0.0 else ""),
                    }
                    w_all.writerow(row)
                    if diff_writer is not None:
                        diff_writer.writerow(row)
                        diff_rows_written += 1
                        diff_filenames.append(filename)
                    rows_written += 1
                    ious.append(0.0)
                    continue

                if int(sb.detected) != 1:
                    iou = 0.0
                    iou_min_conf = 0.0 if (float(args.min_conf) <= 0.0) else ""
                else:
                    sb_poly = _poly_from_quad(sb.coords)
                    if sb_poly is None:
                        iou = 0.0
                        iou_min_conf = 0.0 if (float(args.min_conf) <= 0.0) else ""
                    else:
                        iou = _iou(gt_poly, sb_poly)
                        if float(args.min_conf) > 0.0 and float(sb.conf) >= float(args.min_conf):
                            iou_min_conf = iou
                        elif float(args.min_conf) > 0.0:
                            iou_min_conf = ""
                        else:
                            iou_min_conf = iou

                row = {
                    "split": split,
                    "filename": filename,
                    "gt_valid": 1,
                    "teacher_detected": int(sb.detected),
                    "teacher_conf": float(sb.conf),
                    "iou": float(iou),
                    "iou_at_min_conf": iou_min_conf,
                }
                w_all.writerow(row)
                if diff_writer is not None and (int(sb.detected) != 1 or float(iou) < float(args.diff_iou)):
                    diff_writer.writerow(row)
                    diff_rows_written += 1
                    diff_filenames.append(filename)
                rows_written += 1
                ious.append(float(iou))

        if diff_f is not None:
            diff_f.close()
            diff_txt_path.write_text("".join(f"{n}\n" for n in sorted(set(diff_filenames))))

        if ious:
            ious_np = np.array(ious, dtype=np.float32)
            print("\n" + "=" * 80)
            print(f"{split} summary -> {out_path}")
            print("=" * 80)
            print(f"Positives: {len(positives)}  rows: {rows_written}")
            print(f"Missing/invalid GT: {missing_gt}")
            print(f"Missing teacher rows: {missing_teacher}")
            print(
                "IoU: "
                f"mean={float(ious_np.mean()):.4f}, "
                f"p50={float(np.percentile(ious_np, 50)):.4f}, "
                f"p95={float(np.percentile(ious_np, 95)):.4f}, "
                f"min={float(ious_np.min()):.4f}, "
                f"max={float(ious_np.max()):.4f}"
            )
            if bool(args.write_diff_files):
                print(f"Diff threshold: iou<{float(args.diff_iou):.3f} or undetected")
                print(f"Diff CSV: {diff_csv_path} ({diff_rows_written} rows)")
                print(f"Diff list: {diff_txt_path}")

    print("\nDone.")


if __name__ == "__main__":
    main()
